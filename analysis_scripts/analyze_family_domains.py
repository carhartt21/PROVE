#!/usr/bin/env python3
"""
Family-Domain Analysis Script

Analyzes per-domain weather results grouped by strategy families.
Uses the existing weather_domain_results.csv data generated by analyze_weather_domains.py.

Weather Domains:
- Normal: clear_day, cloudy, dawn_dusk
- Adverse: foggy, night, rainy, snowy

Provides:
- Family × Domain performance heatmaps
- Robustness analysis (adverse vs normal conditions)
- Per-family domain comparisons

Usage:
    mamba run -n prove python analyze_family_domains.py

Prerequisites:
    Run analyze_weather_domains.py first to generate weather_domain_results.csv

Output:
    result_figures/family_analysis/
    
See docs/FAMILY_ANALYSIS.md for detailed documentation.
"""

import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from pathlib import Path
import warnings
warnings.filterwarnings('ignore')

# Output directory
OUTPUT_DIR = Path("result_figures/family_analysis")
OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

# Strategy family definitions
STRATEGY_FAMILIES = {
    "2D Rendering": [
        "gen_imgaug_weather",
        "gen_automold", 
        "gen_Weather_Effect_Generator",
        "std_photometric_distort"
    ],
    "CNN/GAN": [
        "gen_Attribute_Hallucination",
        "gen_cycleGAN",
        "gen_CUT",
        "gen_stargan_v2",
        "gen_SUSTechGAN"
    ],
    "Style Transfer": [
        "gen_NST",
        "gen_LANIT",
        "gen_TSIT",
        # "gen_StyleID"  # EXCLUDED: 0/4 training dataset coverage
    ],
    "Diffusion": [
        "gen_Img2Img",
        "gen_IP2P",
        # "gen_EDICT",  # EXCLUDED: 0/4 training dataset coverage
        "gen_UniControl"
    ],
    "Multimodal Diffusion": [
        "gen_flux1_kontext",
        "gen_step1x_new",
        "gen_Qwen_Image_Edit"
    ],
    "Standard Augmentation": [
        "std_autoaugment",
        "std_randaugment",
        "std_photometric_distort"
    ],
    "Standard Mixing": [
        "std_cutmix",
        "std_mixup"
    ],
    "Baseline": [
        "baseline"
    ]
}

# Reverse mapping
STRATEGY_TO_FAMILY = {}
for family, strategies in STRATEGY_FAMILIES.items():
    for strategy in strategies:
        STRATEGY_TO_FAMILY[strategy] = family

WEATHER_DOMAINS = ['clear_day', 'cloudy', 'dawn_dusk', 'foggy', 'night', 'rainy', 'snowy']
ADVERSE_DOMAINS = ['foggy', 'night', 'rainy', 'snowy']
NORMAL_DOMAINS = ['clear_day', 'cloudy', 'dawn_dusk']


def load_weather_results():
    """Load weather domain results."""
    csv_path = "result_figures/weather_analysis/weather_domain_results.csv"
    if not os.path.exists(csv_path):
        print(f"Weather domain results not found at {csv_path}")
        return pd.DataFrame()
    
    df = pd.read_csv(csv_path)
    df['family'] = df['strategy'].apply(lambda x: STRATEGY_TO_FAMILY.get(x, "Unknown"))
    return df


def create_family_domain_heatmap(df: pd.DataFrame, output_path: Path):
    """Create heatmap of family performance by domain."""
    
    fig, axes = plt.subplots(1, 2, figsize=(16, 8))
    
    # Plot 1: Absolute mIoU
    ax1 = axes[0]
    pivot = df.pivot_table(values='mIoU', index='family', columns='domain', aggfunc='mean')
    col_order = [d for d in WEATHER_DOMAINS if d in pivot.columns]
    pivot = pivot[col_order]
    pivot = pivot.loc[pivot.mean(axis=1).sort_values(ascending=False).index]
    
    sns.heatmap(pivot, annot=True, fmt='.1f', cmap='RdYlGn', ax=ax1,
                cbar_kws={'label': 'mIoU'})
    ax1.set_title('Family Performance by Weather Domain (mIoU)', fontsize=12, fontweight='bold')
    ax1.set_xlabel('Weather Domain')
    ax1.set_ylabel('Strategy Family')
    
    # Plot 2: Improvement over baseline
    ax2 = axes[1]
    if 'improvement' in df.columns:
        pivot_imp = df.pivot_table(values='improvement', index='family', columns='domain', aggfunc='mean')
        pivot_imp = pivot_imp[col_order]
        pivot_imp = pivot_imp.loc[[f for f in pivot.index if f != 'Baseline']]
        
        sns.heatmap(pivot_imp, annot=True, fmt='.2f', cmap='RdYlGn', ax=ax2, center=0,
                    cbar_kws={'label': 'Δ mIoU'})
        ax2.set_title('Improvement over Baseline by Domain', fontsize=12, fontweight='bold')
        ax2.set_xlabel('Weather Domain')
        ax2.set_ylabel('Strategy Family')
    
    plt.tight_layout()
    plt.savefig(output_path, dpi=150, bbox_inches='tight')
    plt.close()
    print(f"Saved: {output_path}")


def create_family_robustness_analysis(df: pd.DataFrame, output_path: Path):
    """Analyze family robustness across weather conditions."""
    
    fig, axes = plt.subplots(2, 2, figsize=(16, 14))
    
    # Add condition type
    df['condition'] = df['domain'].apply(lambda x: 'Adverse' if x in ADVERSE_DOMAINS else 'Normal')
    
    # Plot 1: Adverse vs Normal by family
    ax1 = axes[0, 0]
    cond_pivot = df.pivot_table(values='mIoU', index='family', columns='condition', aggfunc='mean')
    cond_pivot = cond_pivot.sort_values('Adverse', ascending=False)
    
    x = np.arange(len(cond_pivot))
    width = 0.35
    ax1.bar(x - width/2, cond_pivot['Normal'], width, label='Normal', color='#2ecc71')
    ax1.bar(x + width/2, cond_pivot['Adverse'], width, label='Adverse', color='#e74c3c')
    ax1.set_xticks(x)
    ax1.set_xticklabels(cond_pivot.index, rotation=45, ha='right')
    ax1.set_ylabel('Mean mIoU')
    ax1.set_title('Normal vs Adverse Conditions by Family', fontsize=12, fontweight='bold')
    ax1.legend()
    
    # Plot 2: Robustness score (adverse/normal)
    ax2 = axes[0, 1]
    if 'Normal' in cond_pivot.columns and 'Adverse' in cond_pivot.columns:
        robustness = (cond_pivot['Adverse'] / cond_pivot['Normal']).sort_values(ascending=True)
        colors = plt.cm.RdYlGn((robustness - robustness.min()) / (robustness.max() - robustness.min() + 0.01))
        ax2.barh(range(len(robustness)), robustness.values, color=colors)
        ax2.set_yticks(range(len(robustness)))
        ax2.set_yticklabels(robustness.index)
        ax2.axvline(x=1.0, color='red', linestyle='--', linewidth=1.5, label='Parity')
        ax2.set_xlabel('Robustness Score (Adverse/Normal)')
        ax2.set_title('Family Robustness to Adverse Conditions', fontsize=12, fontweight='bold')
        ax2.legend()
    
    # Plot 3: Performance drop from best to worst domain
    ax3 = axes[1, 0]
    domain_pivot = df.pivot_table(values='mIoU', index='family', columns='domain', aggfunc='mean')
    perf_range = domain_pivot.max(axis=1) - domain_pivot.min(axis=1)
    perf_range = perf_range.sort_values(ascending=True)
    
    colors = plt.cm.RdYlGn_r((perf_range - perf_range.min()) / (perf_range.max() - perf_range.min() + 0.01))
    ax3.barh(range(len(perf_range)), perf_range.values, color=colors)
    ax3.set_yticks(range(len(perf_range)))
    ax3.set_yticklabels(perf_range.index)
    ax3.set_xlabel('mIoU Range (Max - Min)')
    ax3.set_title('Performance Variability Across Domains', fontsize=12, fontweight='bold')
    
    # Plot 4: Improvement in adverse vs normal conditions
    ax4 = axes[1, 1]
    if 'improvement' in df.columns:
        non_baseline = df[df['family'] != 'Baseline']
        imp_pivot = non_baseline.pivot_table(values='improvement', index='family', columns='condition', aggfunc='mean')
        
        if not imp_pivot.empty:
            imp_pivot = imp_pivot.sort_values('Adverse', ascending=False)
            
            x = np.arange(len(imp_pivot))
            width = 0.35
            bars1 = ax4.bar(x - width/2, imp_pivot.get('Normal', [0]*len(x)), width, label='Normal', color='#3498db')
            bars2 = ax4.bar(x + width/2, imp_pivot.get('Adverse', [0]*len(x)), width, label='Adverse', color='#e74c3c')
            ax4.set_xticks(x)
            ax4.set_xticklabels(imp_pivot.index, rotation=45, ha='right')
            ax4.axhline(y=0, color='black', linestyle='-', linewidth=0.5)
            ax4.set_ylabel('Improvement over Baseline')
            ax4.set_title('Improvement by Condition Type', fontsize=12, fontweight='bold')
            ax4.legend()
    
    plt.tight_layout()
    plt.savefig(output_path, dpi=150, bbox_inches='tight')
    plt.close()
    print(f"Saved: {output_path}")


def create_intra_family_domain_comparison(df: pd.DataFrame, output_dir: Path):
    """Create per-family domain comparison plots."""
    
    for family in df['family'].unique():
        if family in ['Unknown', 'Baseline']:
            continue
        
        family_df = df[df['family'] == family]
        if len(family_df) == 0:
            continue
        
        fig, axes = plt.subplots(1, 2, figsize=(14, 6))
        
        # Plot 1: Strategy x Domain heatmap
        ax1 = axes[0]
        pivot = family_df.pivot_table(values='mIoU', index='strategy', columns='domain', aggfunc='mean')
        if not pivot.empty:
            col_order = [d for d in WEATHER_DOMAINS if d in pivot.columns]
            if col_order:
                pivot = pivot[col_order]
                sns.heatmap(pivot, annot=True, fmt='.1f', cmap='RdYlGn', ax=ax1)
                ax1.set_title(f'{family}: Strategy Performance by Domain')
        
        # Plot 2: Improvement by domain
        ax2 = axes[1]
        if 'improvement' in family_df.columns:
            imp_pivot = family_df.pivot_table(values='improvement', index='strategy', columns='domain', aggfunc='mean')
            if not imp_pivot.empty:
                col_order = [d for d in WEATHER_DOMAINS if d in imp_pivot.columns]
                if col_order:
                    imp_pivot = imp_pivot[col_order]
                    sns.heatmap(imp_pivot, annot=True, fmt='.2f', cmap='RdYlGn', ax=ax2, center=0)
                    ax2.set_title(f'{family}: Improvement by Domain')
        
        plt.tight_layout()
        safe_name = family.replace(' ', '_').replace('/', '_')
        output_path = output_dir / f"intra_{safe_name}_domains.png"
        plt.savefig(output_path, dpi=150, bbox_inches='tight')
        plt.close()
        print(f"Saved: {output_path}")


def create_comprehensive_summary(df: pd.DataFrame):
    """Create comprehensive summary table."""
    
    summary = []
    
    for family in df['family'].unique():
        family_df = df[df['family'] == family]
        
        # Domain performance
        domain_means = family_df.groupby('domain')['mIoU'].mean()
        
        # Condition performance
        family_df['condition'] = family_df['domain'].apply(
            lambda x: 'Adverse' if x in ADVERSE_DOMAINS else 'Normal'
        )
        cond_means = family_df.groupby('condition')['mIoU'].mean()
        
        row = {
            'Family': family,
            'N_Strategies': family_df['strategy'].nunique(),
            'N_Results': len(family_df),
            'Mean_mIoU': family_df['mIoU'].mean(),
            'Std_mIoU': family_df['mIoU'].std(),
            'Best_Domain': domain_means.idxmax() if len(domain_means) > 0 else 'N/A',
            'Worst_Domain': domain_means.idxmin() if len(domain_means) > 0 else 'N/A',
            'Normal_mIoU': cond_means.get('Normal', np.nan),
            'Adverse_mIoU': cond_means.get('Adverse', np.nan),
        }
        
        if 'Normal' in cond_means and 'Adverse' in cond_means and cond_means['Normal'] > 0:
            row['Robustness'] = cond_means['Adverse'] / cond_means['Normal']
        else:
            row['Robustness'] = np.nan
        
        if 'improvement' in family_df.columns and family != 'Baseline':
            row['Mean_Improvement'] = family_df['improvement'].mean()
            row['Best_Domain_Improvement'] = family_df.groupby('domain')['improvement'].mean().idxmax()
        
        summary.append(row)
    
    summary_df = pd.DataFrame(summary)
    summary_df = summary_df.sort_values('Mean_mIoU', ascending=False)
    
    return summary_df


def main():
    """Main function."""
    
    print("=" * 60)
    print("Family-Domain Analysis")
    print("=" * 60)
    
    # Load data
    print("\nLoading weather domain results...")
    df = load_weather_results()
    
    if len(df) == 0:
        print("No weather domain results available.")
        return
    
    print(f"Loaded {len(df)} results from {df['strategy'].nunique()} strategies")
    print(f"Families with domain data: {df['family'].nunique()}")
    
    # Print coverage
    print("\nFamily coverage:")
    for family in sorted(df['family'].unique()):
        strategies = df[df['family'] == family]['strategy'].unique()
        print(f"  {family}: {len(strategies)} strategies - {', '.join(strategies)}")
    
    # Generate visualizations
    print("\nGenerating visualizations...")
    
    # 1. Family-domain heatmap
    print("  - Family-domain heatmap...")
    create_family_domain_heatmap(df, OUTPUT_DIR / "family_domain_heatmap.png")
    
    # 2. Robustness analysis
    print("  - Robustness analysis...")
    create_family_robustness_analysis(df, OUTPUT_DIR / "family_robustness_analysis.png")
    
    # 3. Intra-family domain comparison
    print("  - Intra-family domain comparisons...")
    create_intra_family_domain_comparison(df, OUTPUT_DIR)
    
    # Create summary
    print("\nCreating summary...")
    summary_df = create_comprehensive_summary(df)
    summary_df.to_csv(OUTPUT_DIR / "family_domain_summary.csv", index=False)
    
    # Print summary
    print("\n" + "=" * 60)
    print("FAMILY-DOMAIN SUMMARY")
    print("=" * 60)
    print(summary_df.to_string(index=False))
    
    # Note about missing data
    print("\n" + "=" * 60)
    print("COVERAGE NOTES")
    print("=" * 60)
    
    missing_families = set(STRATEGY_FAMILIES.keys()) - set(df['family'].unique())
    if missing_families:
        print(f"\nFamilies without per-domain data: {', '.join(missing_families)}")
        print("To get per-domain results, run fine_grained_test.py for strategies in these families.")
    
    all_strategies = [s for strategies in STRATEGY_FAMILIES.values() for s in strategies]
    covered_strategies = set(df['strategy'].unique())
    missing_strategies = set(all_strategies) - covered_strategies
    if missing_strategies:
        print(f"\nStrategies without per-domain data ({len(missing_strategies)}):")
        for s in sorted(missing_strategies):
            family = STRATEGY_TO_FAMILY.get(s, "Unknown")
            print(f"  - {s} ({family})")
    
    print(f"\nResults saved to {OUTPUT_DIR}/")


if __name__ == "__main__":
    main()
